<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>N·ªëi Th√∫ C·ªï ƒêi·ªÉn ‚Äì HTML5 MVP</title>
  <style>
    :root{
      --cell:64px;
      --gap:8px;
      --bg:#0f172a; /* slate-900 */
      --panel:#111827; /* gray-900 */
      --card:#1f2937; /* gray-800 */
      --txt:#e5e7eb; /* gray-200 */
      --accent:#22d3ee; /* cyan-400 */
      --good:#34d399; /* green-400 */
      --warn:#f59e0b; /* amber-500 */
      --bad:#fb7185; /* rose-400 */
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;background:radial-gradient(1200px 800px at 20% 10%,#1e293b 0%,#0b1222 60%,#030712 100%);color:var(--txt)}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:16px 20px;border-bottom:1px solid #2b3345;background:linear-gradient(180deg,rgba(255,255,255,.04),transparent)}
    .title{font-size:20px;font-weight:700;letter-spacing:.3px}
    .stats{display:flex;gap:14px;align-items:center}
    .badge{padding:6px 10px;border-radius:999px;background:var(--card);border:1px solid #2b3345;min-width:84px;text-align:center}
    .badge b{color:var(--accent)}
    main{display:grid;grid-template-columns:320px 1fr;gap:16px;max-width:1200px;margin:18px auto;padding:0 16px 32px}
    @media (max-width: 980px){main{grid-template-columns:1fr}}
    .side{background:var(--panel);border:1px solid #2b3345;border-radius:16px;padding:16px;display:flex;flex-direction:column;gap:12px}
    .side h2{margin:0 0 6px 0;font-size:16px;color:#c7d2fe}
    .controls{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
    button{appearance:none;border:none;background:var(--card);color:var(--txt);padding:10px 12px;border-radius:12px;border:1px solid #2b3345;cursor:pointer;transition:transform .05s ease,background .15s}
    button:hover{background:#243044}
    button:active{transform:translateY(1px)}
    .primary{background:linear-gradient(180deg,#0ea5e9,#0284c7);border-color:#075985}
    .good{background:linear-gradient(180deg,#10b981,#059669);border-color:#065f46}
    .warn{background:linear-gradient(180deg,#f59e0b,#d97706);border-color:#92400e}
    .bad{background:linear-gradient(180deg,#fb7185,#e11d48);border-color:#9f1239}
    .board-wrap{display:flex;align-items:center;justify-content:center}
    .board{position:relative;display:grid;grid-template-columns:repeat(var(--cols),var(--cell));grid-auto-rows:var(--cell);gap:var(--gap);padding:12px;border-radius:18px;background:rgba(17,24,39,.6);border:1px solid #2b3345;backdrop-filter: blur(6px);}
    .tile{width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;font-size:34px;border-radius:14px;background:#0b1020;border:1px solid #2b3345;box-shadow: inset 0 -4px 0 rgba(255,255,255,.04)}
    .tile.obstacle{background:#1b2336}
    .tile .id{display:none}
    .tile.sel{outline:3px solid var(--accent);filter:drop-shadow(0 0 8px rgba(34,211,238,.35))}
    .tile.matched{opacity:.2;transform:scale(.9)}
    .path{position:absolute;inset:0;pointer-events:none}
    .toast{position:fixed;left:50%;top:16px;transform:translateX(-50%);background:#111827;border:1px solid #2b3345;padding:8px 12px;border-radius:999px;color:var(--txt);opacity:0;transition:opacity .2s, transform .2s;}
    .toast.show{opacity:1;transform:translateX(-50%) translateY(6px)}
    .legend{display:grid;grid-template-columns:repeat(8,minmax(0,1fr));gap:6px;font-size:20px}
    .footer{opacity:.7;font-size:12px;margin-top:auto}
    .progress{height:8px;background:#0b1020;border:1px solid #2b3345;border-radius:999px;overflow:hidden}
    .bar{height:100%;width:0;background:linear-gradient(90deg,#34d399,#22d3ee);}
  </style>
</head>
<body>
  <header>
    <div class="title">üêæ N·ªëi Th√∫ C·ªï ƒêi·ªÉn ‚Äì HTML5</div>
    <div class="stats">
      <div class="badge">Level: <b id="level">1</b>/7</div>
      <div class="badge">ƒêi·ªÉm: <b id="score">0</b></div>
      <div class="badge">Combo: <b id="combo">0</b></div>
      <div class="badge">‚è≥ <b id="time">150</b>s</div>
    </div>
  </header>

  <main>
    <section class="side">
      <h2>ƒêi·ªÅu khi·ªÉn</h2>
      <div class="controls">
        <button id="btnHint">G·ª£i √Ω</button>
        <button id="btnShuffle" class="warn">X√°o tr·ªôn (<span id="shuffles">3</span>)</button>
        <button id="btnPause">T·∫°m d·ª´ng</button>
        <button id="btnRestart" class="bad">Ch∆°i l·∫°i</button>
      </div>
      <h2>N·ªÅn t·∫£ng</h2>
      <div class="legend" id="legend"></div>
      <div>
        <h2>Ti·∫øn ƒë·ªô</h2>
        <div class="progress"><div id="timebar" class="bar"></div></div>
      </div>
      <div class="footer">MVP b√°m theo GDD: 10x8, t·ªëi ƒëa 2 g√≥c r·∫Ω, combo 2s c√≥ th∆∞·ªüng, 7 level (v·∫≠t c·∫£n t·ª´ Lv4), quy ƒë·ªïi th·ªùi gian th√†nh ƒëi·ªÉm khi ho√†n th√†nh.</div>
    </section>

    <section class="board-wrap">
      <div class="board" id="board" style="--cols: 8"></div>
    </section>
  </main>

  <div class="toast" id="toast"></div>

  <script>
  // ---- C·∫§U H√åNH LEVEL & ICONS ----
  const ROWS = 10, COLS = 8;
  const ICONS = [
    'üê±','üê∂','üê∞','üêº','üêü','üêß','üêò','ü¶í','ü¶Å','üêµ','ü¶â','ü¶ä','ü¶ì','üêÜ','üêç'
  ];
  const OBSTACLE = 'ü™®';

  const LEVELS = [
    { time:150, types:5,  obstacles:0,  shuffles:3, bg:'grass' },
    { time:120, types:7,  obstacles:0,  shuffles:3, bg:'forest' },
    { time:100, types:9,  obstacles:0,  shuffles:3, bg:'ocean' },
    { time:85,  types:11, obstacles:8,  shuffles:3, bg:'city' },
    { time:70,  types:13, obstacles:12, shuffles:3, bg:'space' },
    { time:60,  types:14, obstacles:16, shuffles:2, bg:'desert' },
    { time:50,  types:15, obstacles:22, shuffles:2, bg:'temple' },
  ];

  // ---- TR·∫†NG TH√ÅI GAME ----
  const state = {
    level: 1,
    score: 0,
    combo: 0,
    timeLeft: 0,
    timerId: null,
    comboTimerId: null,
    lastMatchAt: 0,
    shufflesLeft: 0,
    grid: [],       // d√πng ma tr·∫≠n c√≥ vi·ªÅn r·ªóng ƒë·ªÉ h·ªó tr·ª£ ƒëi ngo√†i r√¨a
    raw: [],        // ma tr·∫≠n hi·ªÉn th·ªã (kh√¥ng vi·ªÅn)
    lock: false,
    sel: null,
  };

  const board = document.getElementById('board');
  const $level = document.getElementById('level');
  const $score = document.getElementById('score');
  const $combo = document.getElementById('combo');
  const $time  = document.getElementById('time');
  const $timebar = document.getElementById('timebar');
  const $toast = document.getElementById('toast');
  const $shuffles = document.getElementById('shuffles');

  // ---- TI·ªÜN √çCH ----
  const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const shuffle=inArr=>{const a=[...inArr];for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a};
  const now=()=>performance.now();

  function toast(msg){
    $toast.textContent=msg; $toast.classList.add('show');
    setTimeout(()=> $toast.classList.remove('show'), 1200);
  }

  // ---- KH·ªûI T·∫†O LEVEL ----
  function startLevel(n){
    state.level = n;
    const cfg = LEVELS[n-1];
    $level.textContent = n;
    state.combo = 0; updateCombo();
    state.timeLeft = cfg.time; updateTime();
    state.shufflesLeft = cfg.shuffles; $shuffles.textContent = state.shufflesLeft;

    // T·∫°o danh s√°ch c·∫∑p bi·ªÉu t∆∞·ª£ng
    const pairsCount = Math.floor((ROWS*COLS - cfg.obstacles)/2);
    const set = ICONS.slice(0, cfg.types);
    const pairs=[];
    for(let i=0;i<pairsCount;i++){ const icon=set[i%set.length]; pairs.push(icon,icon); }
    const cells = shuffle(pairs);

    // Ch√®n v·∫≠t c·∫£n
    let obstacles = cfg.obstacles;
    while(obstacles-->0){ const pos = randInt(0, ROWS*COLS-1); cells.splice(pos,0,OBSTACLE); }
    // N·∫øu th·ª´a √¥ (do ch√®n obstacles), c·∫Øt b·ªõt cu·ªëi ƒë·ªÉ kh·ªõp k√≠ch th∆∞·ªõc
    const flat = cells.slice(0, ROWS*COLS);

    // ƒê∆∞a v√†o ma tr·∫≠n hi·ªÉn th·ªã
    state.raw = Array.from({length:ROWS},(_,r)=> flat.slice(r*COLS,(r+1)*COLS));

    // T·∫°o ma tr·∫≠n c√≥ vi·ªÅn r·ªóng (padding 1) ƒë·ªÉ h·ªó tr·ª£ n·ªëi v√≤ng ngo√†i
    state.grid = Array.from({length:ROWS+2},()=>Array(COLS+2).fill(''));
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) state.grid[r+1][c+1]=state.raw[r][c];

    draw();
    resetTimer();
  }

  function draw(){
    board.innerHTML='';
    board.style.setProperty('--cols', COLS);
    // layer path
    const pathLayer = document.createElement('svg');
    pathLayer.className='path'; pathLayer.setAttribute('viewBox',`0 0 ${(COLS)*(64+8)} ${(ROWS)*(64+8)}`);
    board.appendChild(pathLayer);

    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const val = state.raw[r][c];
        const div = document.createElement('div');
        div.className='tile';
        if(val==='') { div.style.visibility='hidden'; }
        else if(val===OBSTACLE){ div.classList.add('obstacle'); div.textContent=OBSTACLE; }
        else { div.textContent=val; }
        div.dataset.r=r; div.dataset.c=c;
        div.addEventListener('click', onClickTile);
        board.appendChild(div);
      }
    }
  }

  function onClickTile(e){
    if(state.lock) return;
    const r = +e.currentTarget.dataset.r;
    const c = +e.currentTarget.dataset.c;
    const v = state.raw[r][c];
    if(!v || v===OBSTACLE) return;

    if(!state.sel){
      state.sel = {r,c,v,el:e.currentTarget};
      e.currentTarget.classList.add('sel');
      return;
    }

    const a=state.sel, b={r,c,v,el:e.currentTarget};
    if(a.r===b.r && a.c===b.c){ // h·ªßy ch·ªçn
      a.el.classList.remove('sel');
      state.sel=null; return;
    }

    if(a.v!==b.v){ // ƒë·ªïi ch·ªçn
      a.el.classList.remove('sel');
      state.sel=b; b.el.classList.add('sel'); return;
    }

    // th·ª≠ n·ªëi
    const path = canConnect(a.r+1,a.c+1,b.r+1,b.c+1); // d√πng t·ªça ƒë·ªô c√≥ padding
    if(path){
      drawPath(path);
      match(a,b);
    } else {
      toast('Kh√¥ng n·ªëi ƒë∆∞·ª£c!');
      a.el.classList.remove('sel');
      state.sel=b; b.el.classList.add('sel');
    }
  }

  function drawPath(nodes){
    const svg = board.querySelector('svg.path');
    svg.innerHTML='';
    const g = document.createElementNS('http://www.w3.org/2000/svg','polyline');
    g.setAttribute('fill','none');
    g.setAttribute('stroke','url(#grad)');
    g.setAttribute('stroke-width','6');
    const pts = nodes.map(([R,C])=>{
      const x = (C-1)*(64+8)+32+12; // 64 cell + 8 gap + 12 board padding
      const y = (R-1)*(64+8)+32+12;
      return `${x},${y}`;
    }).join(' ');
    g.setAttribute('points', pts);

    const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
    const grad = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
    grad.id='grad'; grad.setAttribute('x1','0%');grad.setAttribute('x2','100%');grad.setAttribute('y1','0%');grad.setAttribute('y2','0%');
    const s1=document.createElementNS('http://www.w3.org/2000/svg','stop');s1.setAttribute('offset','0%');s1.setAttribute('stop-color','#34d399');
    const s2=document.createElementNS('http://www.w3.org/2000/svg','stop');s2.setAttribute('offset','100%');s2.setAttribute('stop-color','#22d3ee');
    grad.appendChild(s1);grad.appendChild(s2);defs.appendChild(grad);svg.appendChild(defs);

    svg.appendChild(g);
    setTimeout(()=> svg.innerHTML='', 280);
  }

  function match(a,b){
    // x√≥a
    state.raw[a.r][a.c]='';
    state.raw[b.r][b.c]='';
    state.grid[a.r+1][a.c+1]='';
    state.grid[b.r+1][b.c+1]='';

    a.el.classList.remove('sel');
    a.el.classList.add('matched');
    b.el.classList.add('matched');
    state.sel=null;

    // ƒëi·ªÉm + combo
    const base=10;
    const t = now();
    if(t - state.lastMatchAt <= 2000){ state.combo++; }
    else { state.combo=1; }
    state.lastMatchAt=t;

    let bonus=0;
    if(state.combo===1) bonus=0;          // 10
    else if(state.combo===2) bonus=10;    // 20
    else if(state.combo===3) bonus=20;    // 30
    else if(state.combo===4) { bonus=30; addTime(5); toast('+5s ‚ú® Combo 4'); }
    else if(state.combo>=5) bonus=40;     // 50

    state.score += base + bonus;
    updateScore(); updateCombo();

    // n√©n xu·ªëng d∆∞·ªõi
    applyGravity();
    draw();

    // th·∫Øng?
    if(isBoardCleared()){
      levelClear();
    }
  }

  function applyGravity(){
    for(let c=0;c<COLS;c++){
      let stack=[]; // t·ª´ d∆∞·ªõi l√™n
      for(let r=ROWS-1;r>=0;r--){
        const v=state.raw[r][c];
        if(v==='') continue; // √¥ tr·ªëng
        stack.push(v);
      }
      // ƒë·ªï l·∫°i t·ª´ d∆∞·ªõi
      for(let r=ROWS-1;r>=0;r--){
        state.raw[r][c] = stack[ROWS-1-r] ?? '';
      }
    }
    // c·∫≠p nh·∫≠t grid c√≥ vi·ªÅn
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) state.grid[r+1][c+1]=state.raw[r][c];
  }

  function isBoardCleared(){
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const v=state.raw[r][c]; if(v && v!==OBSTACLE) return false;
    }
    return true;
  }

  function levelClear(){
    stopTimer();
    const remain = Math.max(0, state.timeLeft);
    const bonus = remain*10; // quy ƒë·ªïi th·ªùi gian x10
    state.score += bonus; updateScore();
    toast(`Ho√†n th√†nh level! +${bonus} ƒëi·ªÉm th·ªùi gian`);

    if(state.level<LEVELS.length){
      setTimeout(()=> startLevel(state.level+1), 900);
    } else {
      setTimeout(()=> alert(`üéâ B·∫°n ƒë√£ th·∫Øng game! T·ªïng ƒëi·ªÉm: ${state.score}`), 600);
    }
  }

  // ---- TIMER ----
  function resetTimer(){
    stopTimer();
    const total = LEVELS[state.level-1].time;
    const start = performance.now();
    state.timerId = setInterval(()=>{
      const dt = Math.floor((performance.now()-start)/1000);
      state.timeLeft = Math.max(0, total - dt);
      updateTime();
      if(state.timeLeft<=0){ gameOver(); }
    }, 250);
  }
  function stopTimer(){ if(state.timerId){ clearInterval(state.timerId); state.timerId=null; }}
  function addTime(s){ state.timeLeft += s; updateTime(true); }
  function updateTime(boost=false){
    $time.textContent = state.timeLeft;
    const cfg = LEVELS[state.level-1];
    const p = Math.max(0, Math.min(1, state.timeLeft / cfg.time));
    $timebar.style.width = (p*100)+"%";
    if(boost){ $timebar.animate([{transform:'scaleY(1.0)'},{transform:'scaleY(1.3)'}],{duration:180}); }
  }

  function updateScore(){ $score.textContent = state.score; }
  function updateCombo(){ $combo.textContent = state.combo; }

  function gameOver(){
    stopTimer();
    alert('‚è∞ H·∫øt th·ªùi gian! Thua cu·ªôc.');
    startLevel(1); state.score=0; updateScore();
  }

  // ---- LOGIC N·ªêI T·ªêI ƒêA 2 G√ìC R·∫º ----
  function canConnect(r1,c1,r2,c2){
    if(r1===r2 && c1===c2) return null;
    // ch·ªâ n·ªëi gi·ªØa hai icon gi·ªëng nhau & kh√¥ng ph·∫£i obstacle
    if(state.grid[r1][c1]!==state.grid[r2][c2]) return null;
    if(state.grid[r1][c1]===OBSTACLE || !state.grid[r1][c1]) return null;

    // 0. t·∫°m th·ªùi l√†m tr·ªëng hai ƒëi·ªÉm ƒë·ªÉ ki·ªÉm tra ƒë∆∞·ªùng ƒëi
    const val = state.grid[r1][c1];
    state.grid[r1][c1]=''; state.grid[r2][c2]='';

    // A. c√πng h√†ng/c·ªôt: ƒë∆∞·ªùng th·∫≥ng
    if(clearLine(r1,c1,r2,c2)) { restore(); return [[r1,c1],[r2,c2]]; }

    // B. 1 g√≥c (L): th·ª≠ (r1,c2) v√† (r2,c1)
    if(isEmpty(r1,c2) && clearLine(r1,c1,r1,c2) && clearLine(r1,c2,r2,c2)) { restore(); return [[r1,c1],[r1,c2],[r2,c2]]; }
    if(isEmpty(r2,c1) && clearLine(r1,c1,r2,c1) && clearLine(r2,c1,r2,c2)) { restore(); return [[r1,c1],[r2,c1],[r2,c2]]; }

    // C. 2 g√≥c (Z): duy·ªát theo c·ªôt trung gian & h√†ng trung gian
    for(let cc=0; cc<state.grid[0].length; cc++){
      if(cc===c1||cc===c2) continue;
      if(isEmpty(r1,cc) && isEmpty(r2,cc) && clearLine(r1,c1,r1,cc) && clearLine(r1,cc,r2,cc) && clearLine(r2,cc,r2,c2)) { restore(); return [[r1,c1],[r1,cc],[r2,cc],[r2,c2]]; }
    }
    for(let rr=0; rr<state.grid.length; rr++){
      if(rr===r1||rr===r2) continue;
      if(isEmpty(rr,c1) && isEmpty(rr,c2) && clearLine(r1,c1,rr,c1) && clearLine(rr,c1,rr,c2) && clearLine(rr,c2,r2,c2)) { restore(); return [[r1,c1],[rr,c1],[rr,c2],[r2,c2]]; }
    }

    restore();
    return null;

    function restore(){ state.grid[r1][c1]=val; state.grid[r2][c2]=val; }
  }

  function isEmpty(r,c){ return state.grid[r] && state.grid[r][c]===""; }

  function clearLine(r1,c1,r2,c2){
    if(r1===r2){ // ngang
      const [a,b] = c1<c2 ? [c1,c2] : [c2,c1];
      for(let c=a+1;c<b;c++) if(state.grid[r1][c]!=="") return false;
      return true;
    }
    if(c1===c2){ // d·ªçc
      const [a,b] = r1<r2 ? [r1,r2] : [r2,r1];
      for(let r=a+1;r<b;r++) if(state.grid[r][c1]!=="") return false;
      return true;
    }
    return false; // ch·ªâ ki·ªÉm tra ƒë∆∞·ªùng th·∫≥ng
  }

  // ---- HINT & SHUFFLE ----
  function findAnyPair(){
    // duy·ªát t·∫•t c·∫£ c·∫∑p c√≥ th·ªÉ n·ªëi (t·ªëi ƒëa v√†i trƒÉm, OK)
    for(let r1=0;r1<ROWS;r1++) for(let c1=0;c1<COLS;c1++){
      const v=state.raw[r1][c1]; if(!v || v===OBSTACLE) continue;
      for(let r2=r1;r2<ROWS;r2++) for(let c2=0;c2<COLS;c2++){
        if(r1===r2 && c2<=c1) continue;
        if(state.raw[r2][c2]!==v) continue;
        const path=canConnect(r1+1,c1+1,r2+1,c2+1);
        if(path) return {r1,c1,r2,c2,path};
      }
    }
    return null;
  }

  function hint(){
    const p = findAnyPair();
    if(!p){ toast('Kh√¥ng c√≤n n∆∞·ªõc ƒëi!'); return; }
    // highlight
    const idx1 = p.r1*COLS + p.c1;
    const idx2 = p.r2*COLS + p.c2;
    const tiles = [...board.querySelectorAll('.tile')];
    tiles[idx1].classList.add('sel'); tiles[idx2].classList.add('sel');
    drawPath(p.path);
    setTimeout(()=>{ tiles[idx1].classList.remove('sel'); tiles[idx2].classList.remove('sel'); }, 500);
  }

  function shuffleBoard(force=false){
    if(!force){
      if(state.shufflesLeft<=0){ toast('H·∫øt l∆∞·ª£t x√°o tr·ªôn'); return; }
      state.shufflesLeft--; $shuffles.textContent=state.shufflesLeft;
    }
    // gom t·∫•t c·∫£ icon (tr·ª´ obstacle, √¥ tr·ªëng)
    const items=[];
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const v=state.raw[r][c]; if(v && v!==OBSTACLE) items.push(v);
    }
    const mixed = shuffle(items);
    let k=0;
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const v=state.raw[r][c];
      if(v===OBSTACLE) continue;
      if(v!=='') state.raw[r][c]=mixed[k++];
    }
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) state.grid[r+1][c+1]=state.raw[r][c];
    draw();
  }

  // ---- S·ª∞ KI·ªÜN UI ----
  document.getElementById('btnHint').addEventListener('click', hint);
  document.getElementById('btnShuffle').addEventListener('click', ()=>{
    shuffleBoard(false);
  });
  document.getElementById('btnPause').addEventListener('click', ()=>{
    if(state.timerId){ stopTimer(); toast('ƒê√£ t·∫°m d·ª´ng'); }
    else { resetTimer(); toast('Ti·∫øp t·ª•c'); }
  });
  document.getElementById('btnRestart').addEventListener('click', ()=>{
    state.score=0; updateScore(); startLevel(1);
  });

  // ---- LEGEND ----
  (function renderLegend(){
    const legend=document.getElementById('legend');
    legend.innerHTML='';
    for(const ic of ICONS){ const s=document.createElement('div'); s.className='tile'; s.textContent=ic; legend.appendChild(s); }
    const ob=document.createElement('div'); ob.className='tile obstacle'; ob.textContent=OBSTACLE; legend.appendChild(ob);
  })();

  // ---- B·∫ÆT ƒê·∫¶U ----
  startLevel(1);
  // ƒë·∫£m b·∫£o lu√¥n c√≥ n∆∞·ªõc ƒëi; n·∫øu kh√¥ng, auto x√°o tr·ªôn ·∫©n
  setInterval(()=>{ if(!findAnyPair()) shuffleBoard(true); }, 2000);

  </script>
</body>
</html>
