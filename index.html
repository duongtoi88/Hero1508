<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>N·ªëi Th√∫ C·ªï ƒêi·ªÉn ‚Äì 1-file (assets + path)</title>
  <style>
    :root{
      --cell:64px; --gap:8px;
      --panel:#111827; --card:#1f2937; --txt:#e5e7eb;
      --accent:#22d3ee; --border:#2b3345;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;
      background:radial-gradient(1200px 800px at 20% 10%,#1e293b 0%,#0b1222 60%,#030712 100%);
      color:var(--txt);
    }
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;
      padding:16px 20px;border-bottom:1px solid var(--border);
      background:linear-gradient(180deg,rgba(255,255,255,.04),transparent)}
    .title{font-size:20px;font-weight:700}
    .stats{display:flex;gap:14px}
    .badge{padding:6px 10px;border-radius:999px;background:var(--card);border:1px solid var(--border)}
    .badge b{color:var(--accent)}
    main{display:grid;grid-template-columns:320px 1fr;gap:16px;max-width:1200px;margin:18px auto;padding:0 16px 32px}
    @media (max-width:980px){main{grid-template-columns:1fr}}
    .side{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:16px;display:flex;flex-direction:column;gap:12px}
    .side h2{margin:0 0 6px;font-size:16px;color:#c7d2fe}
    .controls{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
    button{appearance:none;border:none;background:var(--card);color:var(--txt);
      padding:10px 12px;border-radius:12px;border:1px solid var(--border);cursor:pointer}
    button:hover{background:#243044} button:active{transform:translateY(1px)}
    .warn{background:linear-gradient(180deg,#f59e0b,#d97706)} .bad{background:linear-gradient(180deg,#fb7185,#e11d48)}
    .primary{background:linear-gradient(180deg,#0ea5e9,#0284c7)}
    .board-wrap{position:relative;display:flex;align-items:center;justify-content:center}
    .board{
      position:relative;display:grid;
      grid-template-columns:repeat(var(--cols),var(--cell));
      grid-auto-rows:var(--cell); gap:var(--gap);
      padding:12px;border-radius:18px;background:rgba(17,24,39,.6);
      border:1px solid var(--border);backdrop-filter:blur(6px)
    }
    .tile{
      width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;
      border-radius:14px;background:#0b1020;border:1px solid var(--border)
    }
    .tile img{width:100%;height:100%;object-fit:contain;pointer-events:none;user-select:none;-webkit-user-drag:none}
    .tile.obstacle{background:#1b2336}
    .tile.sel{outline:3px solid var(--accent);filter:drop-shadow(0 0 8px rgba(34,211,238,.35))}
    .tile.matched{opacity:.2;transform:scale(.9)}
    .legend{display:grid;grid-template-columns:repeat(8,minmax(0,1fr));gap:6px}
    .progress{height:8px;background:#0b1020;border:1px solid var(--border);border-radius:999px;overflow:hidden}
    .bar{height:100%;width:0;background:linear-gradient(90deg,#34d399,#22d3ee)}
    .toast{position:fixed;left:50%;top:16px;transform:translateX(-50%);
      background:#111827;border:1px solid var(--border);padding:8px 12px;border-radius:999px;opacity:0;
      transition:opacity .2s,transform .2s}
    .toast.show{opacity:1;transform:translateX(-50%) translateY(6px)}
    .path{position:absolute;inset:0;pointer-events:none}
    .sep{height:1px;background:var(--border);margin:6px 0 10px}
    .toggle{display:flex;align-items:center;gap:8px}
    .sr-only{position:absolute;width:1px;height:1px;margin:-1px;overflow:hidden;clip:rect(0,0,0,0)}
    button:disabled{opacity:.5;cursor:not-allowed;filter:grayscale(.3)}
    :focus-visible{outline:3px solid var(--accent);outline-offset:2px;border-radius:12px}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;backdrop-filter:blur(3px);z-index:20}
    .overlay-card{background:#0b1020;border:1px solid var(--border);border-radius:16px;padding:18px;min-width:280px;max-width:90vw}
    .overlay-card .row{display:flex;gap:10px;margin:8px 0 6px}
  </style>
</head>
<body>
  <header>
    <div class="title">üêæ N·ªëi Th√∫ C·ªï ƒêi·ªÉn ‚Äì 1-file</div>
    <div class="stats">
      <div class="badge">Level: <b id="level">1</b>/7</div>
      <div class="badge">ƒêi·ªÉm: <b id="score">0</b></div>
      <div class="badge">Combo: <b id="combo">0</b></div>
      <div class="badge">‚è≥ <b id="time">150</b>s</div>
    </div>
  </header>

  <main>
    <section class="side">
      <h2>ƒêi·ªÅu khi·ªÉn</h2>
      <div class="controls">
        <button id="btnHint">G·ª£i √Ω</button>
        <button id="btnShuffle" class="warn">X√°o tr·ªôn (<span id="shuffles">3</span>)</button>
        <button id="btnPause">T·∫°m d·ª´ng</button>
        <button id="btnRestart" class="bad">Ch∆°i l·∫°i</button>
      </div>
      <h2>N·ªÅn t·∫£ng</h2>
      <div class="legend" id="legend"></div>
      <div>
        <h2>Ti·∫øn ƒë·ªô</h2>
        <div class="progress"><div id="timebar" class="bar"></div></div>
      </div>

      <div class="sep"></div>
      <h2>C√†i ƒë·∫∑t</h2>
      <label class="toggle"><input id="optAutoShuffle" type="checkbox" checked /> <span>T·ª± x√°o tr·ªôn khi b√≠</span></label>
      <label class="toggle"><input id="optFastTimer" type="checkbox" /> <span>Timer nhanh (debug)</span></label>
      <div id="srLive" class="sr-only" aria-live="polite"></div>

      <div class="footer">D√πng ·∫£nh assets + hi·ªÉn th·ªã ƒë∆∞·ªùng n·ªëi (SVG)</div>
    </section>

    <section class="board-wrap">
      <div class="board" id="board" style="--cols: 8" role="grid" aria-label="B√†n ch∆°i n·ªëi th√∫"></div>
      <svg class="path" id="pathLayer"></svg>
    </section>
  </main>

  <div class="toast" id="toast"></div>

  <div id="overlay" class="overlay" hidden>
    <div class="overlay-card" role="dialog" aria-modal="true" aria-labelledby="pausedTitle">
      <h3 id="pausedTitle">T·∫°m d·ª´ng</h3>
      <p>Nh·∫•n <kbd>P</kbd> ho·∫∑c ‚ÄúTi·∫øp t·ª•c‚Äù.</p>
      <div class="row">
        <button id="btnResume" class="primary">Ti·∫øp t·ª•c</button>
        <button id="btnRestart2" class="bad">Ch∆°i l·∫°i</button>
      </div>
      <p class="hint">Ph√≠m t·∫Øt: <kbd>P</kbd> pause, <kbd>H</kbd> hint, <kbd>R</kbd> restart</p>
    </div>
  </div>

  <script>
    // ====== C·∫§U H√åNH S·ª¨ D·ª§NG ·∫¢NH T·ª™ assets/ + V·∫º ƒê∆Ø·ªúNG N·ªêI ======
    const ROWS=10, COLS=8;
    const ICON_IDS = Array.from({length:15}, (_,i)=> i+1);
    const OBSTACLE = -1;
    const ASSET = { iconUrl: id => `assets/icon_${id}.png`, obstacleUrl: `assets/obstacle.png` };

    const LEVELS = [
      { time:150, types:5,  obstacles:0,  shuffles:3 },
      { time:120, types:7,  obstacles:0,  shuffles:3 },
      { time:100, types:9,  obstacles:0,  shuffles:3 },
      { time:85,  types:11, obstacles:8,  shuffles:3 },
      { time:70,  types:13, obstacles:12, shuffles:3 },
      { time:60,  types:14, obstacles:16, shuffles:2 },
      { time:50,  types:15, obstacles:22, shuffles:2 },
    ];

    // ====== TR·∫†NG TH√ÅI ======
    const state = {
      level: 1, score: 0, combo: 0,
      timeLeft: 0, timerId: null, lastMatchAt: 0,
      shufflesLeft: 0, grid: [], raw: [], sel: null, lock:false,
      // v0.2
      paused:false, autoShuffle:true, fastTimer:false, autoShuffleTimerId:null
    };

    // ====== DOM ======
    const board=document.getElementById('board'), pathLayer=document.getElementById('pathLayer');
    const $level=document.getElementById('level'), $score=document.getElementById('score'), $combo=document.getElementById('combo');
    const $time=document.getElementById('time'), $timebar=document.getElementById('timebar'), $toast=document.getElementById('toast');
    const $shuffles=document.getElementById('shuffles'), $overlay=document.getElementById('overlay');
    const $btnResume=document.getElementById('btnResume'), $btnRestart2=document.getElementById('btnRestart2');
    const $optAutoShuffle=document.getElementById('optAutoShuffle'), $optFastTimer=document.getElementById('optFastTimer'), $srLive=document.getElementById('srLive');

    // ====== TI·ªÜN √çCH ======
    const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const shuffle=a=>{a=[...a];for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a};
    const now=()=>performance.now();
    function speak(m){ if($srLive) $srLive.textContent=m; }
    function toast(m){ $toast.textContent=m; $toast.classList.add('show'); speak(m); setTimeout(()=> $toast.classList.remove('show'), 1200); }

    // LocalStorage
    const LS={BEST:'onet_bestScore',LAST:'onet_lastLevel',OPTS:'onet_options'};
    function saveBest(s){const c=Number(localStorage.getItem(LS.BEST)||0); if(s>c){localStorage.setItem(LS.BEST,String(s)); toast(`üèÜ Best m·ªõi: ${s}`);} }
    function saveLastLevel(l){localStorage.setItem(LS.LAST,String(l));}
    function saveOptions(){localStorage.setItem(LS.OPTS, JSON.stringify({autoShuffle:state.autoShuffle,fastTimer:state.fastTimer}));}
    function loadPersist(){
      const last=Number(localStorage.getItem(LS.LAST)||1);
      const opts=JSON.parse(localStorage.getItem(LS.OPTS)||'{}');
      if(last>=1 && last<=LEVELS.length) state.level=last;
      if(opts.autoShuffle!==undefined){state.autoShuffle=!!opts.autoShuffle; $optAutoShuffle.checked=state.autoShuffle;}
      if(opts.fastTimer!==undefined){state.fastTimer=!!opts.fastTimer; $optFastTimer.checked=state.fastTimer;}
    }

    // ====== KH·ªûI T·∫†O LEVEL ======
    function startLevel(n){
      state.level=n; const cfg=LEVELS[n-1];
      $level.textContent=n; state.combo=0; updateCombo();
      state.timeLeft=cfg.time; updateTime(); state.shufflesLeft=cfg.shuffles; $shuffles.textContent=state.shufflesLeft;

      // t·∫°o c·∫∑p ID
      const pairsCount = Math.floor((ROWS*COLS - cfg.obstacles)/2);
      const set = ICON_IDS.slice(0, cfg.types);
      const pairs=[];
      for(let i=0;i<pairsCount;i++){ const id=set[i%set.length]; pairs.push(id,id); }
      const cells = shuffle(pairs);

      // ch√®n obstacle
      let obstacles=cfg.obstacles;
      while(obstacles-->0){ const pos=randInt(0, ROWS*COLS-1); cells.splice(pos,0,OBSTACLE); }
      const flat = cells.slice(0, ROWS*COLS);

      // raw & grid (c√≥ vi·ªÅn)
      state.raw = Array.from({length:ROWS},(_,r)=> flat.slice(r*COLS,(r+1)*COLS));
      state.grid=Array.from({length:ROWS+2},()=>Array(COLS+2).fill(''));
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) state.grid[r+1][c+1]=state.raw[r][c];

      draw();
      resetTimer();
    }

    // ====== V·∫º BOARD (d√πng ·∫£nh assets) ======
    function draw(){
      board.innerHTML='';
      board.style.setProperty('--cols', COLS);
      pathLayer.innerHTML='';
      pathLayer.setAttribute('viewBox',`0 0 ${(COLS)*(64+8)} ${(ROWS)*(64+8)}`);

      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const val = state.raw[r][c];
          const div = document.createElement('div');
          div.className='tile';
          div.dataset.r=r; div.dataset.c=c;
          div.setAttribute('role','gridcell');

          if(val==='' || val===undefined){ div.style.visibility='hidden'; }
          else if(val===OBSTACLE){
            const img=document.createElement('img');
            img.alt='Obstacle'; img.src=ASSET.obstacleUrl;
            // fallback: n·∫øu thi·∫øu ·∫£nh obstacle, hi·ªán ch·ªØ ü™®
            img.onerror=()=>{ img.remove(); div.textContent='ü™®'; };
            div.classList.add('obstacle'); div.appendChild(img);
          } else {
            const img=document.createElement('img');
            img.alt=`icon_${val}`; img.src=ASSET.iconUrl(val);
            // fallback: n·∫øu thi·∫øu ·∫£nh icon, hi·ªán s·ªë ID
            img.onerror=()=>{ img.remove(); div.textContent=`${val}`; };
            div.appendChild(img);
          }

          div.addEventListener('click', onClickTile);
          board.appendChild(div);
        }
      }
    }

    // ====== CLICK ======
    function onClickTile(e){
      if(state.lock || state.paused) return;
      const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c;
      const v=state.raw[r][c];
      if(v==='' || v===undefined || v===OBSTACLE) return;

      if(!state.sel){
        state.sel={r,c,v,el:e.currentTarget}; e.currentTarget.classList.add('sel'); return;
      }
      const a=state.sel, b={r,c,v,el:e.currentTarget};
      if(a.r===b.r && a.c===b.c){ a.el.classList.remove('sel'); state.sel=null; return; }
      if(a.v!==b.v){ a.el.classList.remove('sel'); state.sel=b; b.el.classList.add('sel'); return; }

      const path = canConnect(a.r+1,a.c+1,b.r+1,b.c+1);
      if(path){ drawPath(path); match(a,b); }
      else { toast('Kh√¥ng n·ªëi ƒë∆∞·ª£c!'); a.el.classList.remove('sel'); state.sel=b; b.el.classList.add('sel'); }
    }

    // ====== V·∫º ƒê∆Ø·ªúNG N·ªêI (SVG overlay) ======
    function drawPath(nodes){
      const svg = pathLayer;
      svg.innerHTML='';
      const g = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      g.setAttribute('fill','none'); g.setAttribute('stroke','url(#grad)'); g.setAttribute('stroke-width','6');
      const pts = nodes.map(([R,C])=>{
        const x=(C-1)*(64+8)+32+12, y=(R-1)*(64+8)+32+12; return `${x},${y}`;
      }).join(' ');
      g.setAttribute('points', pts);

      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const grad = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
      grad.id='grad'; grad.setAttribute('x1','0%');grad.setAttribute('x2','100%');grad.setAttribute('y1','0%');grad.setAttribute('y2','0%');
      const s1=document.createElementNS('http://www.w3.org/2000/svg','stop');s1.setAttribute('offset','0%');s1.setAttribute('stop-color','#34d399');
      const s2=document.createElementNS('http://www.w3.org/2000/svg','stop');s2.setAttribute('offset','100%');s2.setAttribute('stop-color','#22d3ee');
      grad.appendChild(s1); grad.appendChild(s2); defs.appendChild(grad); svg.appendChild(defs);

      svg.appendChild(g);
      setTimeout(()=> svg.innerHTML='', 280);
    }

    // ====== MATCH / GRAVITY / WIN ======
    function match(a,b){
      state.raw[a.r][a.c]=''; state.raw[b.r][b.c]='';
      state.grid[a.r+1][a.c+1]=''; state.grid[b.r+1][b.c+1]='';
      a.el.classList.remove('sel'); a.el.classList.add('matched'); b.el.classList.add('matched'); state.sel=null;

      // ƒëi·ªÉm + combo
      const base=10; const t=now();
      if(t - state.lastMatchAt <= 2000) state.combo++; else state.combo=1;
      state.lastMatchAt=t;
      let bonus=0;
      if(state.combo===2) bonus=10;
      else if(state.combo===3) bonus=20;
      else if(state.combo===4){ bonus=30; addTime(5); toast('+5s ‚ú® Combo 4'); }
      else if(state.combo>=5) bonus=40;
      state.score += base + bonus; updateScore(); updateCombo();

      applyGravity(); draw();
      if(isBoardCleared()) levelClear();
    }
    function applyGravity(){
      for(let c=0;c<COLS;c++){
        let stack=[];
        for(let r=ROWS-1;r>=0;r--){ const v=state.raw[r][c]; if(v==='') continue; stack.push(v); }
        for(let r=ROWS-1;r>=0;r--){ state.raw[r][c]= stack[ROWS-1-r] ?? ''; }
      }
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) state.grid[r+1][c+1]=state.raw[r][c];
    }
    function isBoardCleared(){ for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const v=state.raw[r][c]; if(v && v!==OBSTACLE) return false; } return true; }
    function levelClear(){
      stopTimer();
      const remain=Math.max(0,state.timeLeft), bonus=remain*10;
      state.score+=bonus; updateScore(); toast(`Ho√†n th√†nh level! +${bonus} ƒëi·ªÉm`);
      saveBest(state.score); saveLastLevel(Math.min(state.level+1, LEVELS.length)); saveOptions();
      if(state.level<LEVELS.length){ setTimeout(()=> startLevel(state.level+1), 900); }
      else { setTimeout(()=> alert(`üéâ Th·∫Øng game! T·ªïng ƒëi·ªÉm: ${state.score}`), 600); }
    }

    // ====== TIMER ======
    function resetTimer(resume=false){
      stopTimer();
      const cfg=LEVELS[state.level-1], total=resume?state.timeLeft:cfg.time, speed=state.fastTimer?2:1, start=performance.now();
      state.timerId=setInterval(()=>{
        if(state.paused) return;
        const dt=Math.floor((performance.now()-start)/1000)*speed;
        state.timeLeft=Math.max(0,total-dt); updateTime();
        if(state.timeLeft<=0) gameOver();
      },250);
    }
    function stopTimer(){ if(state.timerId){ clearInterval(state.timerId); state.timerId=null; } }
    function addTime(s){ state.timeLeft+=s; updateTime(true); }
    function updateTime(boost=false){
      $time.textContent=state.timeLeft;
      const cfg=LEVELS[state.level-1], p=Math.max(0,Math.min(1,state.timeLeft/cfg.time));
      $timebar.style.width=(p*100)+'%';
      if(boost){ $timebar.animate([{transform:'scaleY(1)'},{transform:'scaleY(1.3)'}],{duration:180}); }
    }
    function updateScore(){ $score.textContent=state.score; }
    function updateCombo(){ $combo.textContent=state.combo; }
    function gameOver(){
      stopTimer(); alert('‚è∞ H·∫øt th·ªùi gian!');
      saveBest(state.score); saveLastLevel(1); saveOptions();
      startLevel(1); state.score=0; updateScore();
    }

    // ====== LOGIC N·ªêI (‚â§ 2 g√≥c r·∫Ω) ======
    function canConnect(r1,c1,r2,c2){
      if(r1===r2 && c1===c2) return null;
      if(state.grid[r1][c1] !== state.grid[r2][c2]) return null;
      if(state.grid[r1][c1] === OBSTACLE || state.grid[r1][c1] === '' || state.grid[r1][c1] === undefined) return null;

      const val = state.grid[r1][c1];
      state.grid[r1][c1]=''; state.grid[r2][c2]='';

      if(clearLine(r1,c1,r2,c2)){ restore(); return [[r1,c1],[r2,c2]]; }
      if(isEmpty(r1,c2) && clearLine(r1,c1,r1,c2) && clearLine(r1,c2,r2,c2)){ restore(); return [[r1,c1],[r1,c2],[r2,c2]]; }
      if(isEmpty(r2,c1) && clearLine(r1,c1,r2,c1) && clearLine(r2,c1,r2,c2)){ restore(); return [[r1,c1],[r2,c1],[r2,c2]]; }

      for(let cc=0; cc<state.grid[0].length; cc++){
        if(cc===c1||cc===c2) continue;
        if(isEmpty(r1,cc) && isEmpty(r2,cc) && clearLine(r1,c1,r1,cc) && clearLine(r1,cc,r2,cc) && clearLine(r2,cc,r2,c2)){
          restore(); return [[r1,c1],[r1,cc],[r2,cc],[r2,c2]];
        }
      }
      for(let rr=0; rr<state.grid.length; rr++){
        if(rr===r1||rr===r2) continue;
        if(isEmpty(rr,c1) && isEmpty(rr,c2) && clearLine(r1,c1,rr,c1) && clearLine(rr,c1,rr,c2) && clearLine(rr,c2,r2,c2)){
          restore(); return [[r1,c1],[rr,c1],[rr,c2],[r2,c2]];
        }
      }
      restore(); return null;

      function restore(){ state.grid[r1][c1]=val; state.grid[r2][c2]=val; }
    }
    function isEmpty(r,c){ return state.grid[r] && state.grid[r][c]===""; }
    function clearLine(r1,c1,r2,c2){
      if(r1===r2){
        const [a,b]=c1<c2?[c1,c2]:[c2,c1];
        for(let c=a+1;c<b;c++) if(state.grid[r1][c] !== "") return false;
        return true;
      }
      if(c1===c2){
        const [a,b]=r1<r2?[r1,r2]:[r2,r1];
        for(let r=a+1;r<b;r++) if(state.grid[r][c1] !== "") return false;
        return true;
      }
      return false;
    }

    // ====== HINT & SHUFFLE ======
    function findAnyPair(){
      for(let r1=0;r1<ROWS;r1++) for(let c1=0;c1<COLS;c1++){
        const v=state.raw[r1][c1]; if(!v || v===OBSTACLE) continue;
        for(let r2=r1;r2<ROWS;r2++) for(let c2=0;c2<COLS;c2++){
          if(r1===r2 && c2<=c1) continue;
          if(state.raw[r2][c2]!==v) continue;
          const path=canConnect(r1+1,c1+1,r2+1,c2+1); if(path) return {r1,c1,r2,c2,path};
        }
      }
      return null;
    }
    function hint(){
      if(state.paused) return;
      const p=findAnyPair();
      if(!p){ toast('Kh√¥ng c√≤n n∆∞·ªõc ƒëi!'); return; }
      const idx1=p.r1*COLS+p.c1, idx2=p.r2*COLS+p.c2, tiles=[...board.querySelectorAll('.tile')];
      tiles[idx1].classList.add('sel'); tiles[idx2].classList.add('sel'); drawPath(p.path);
      setTimeout(()=>{ tiles[idx1].classList.remove('sel'); tiles[idx2].classList.remove('sel'); }, 500);
    }
    function shuffleBoard(force=false){
      if(state.paused) return;
      if(!force){
        if(state.shufflesLeft<=0){ toast('H·∫øt l∆∞·ª£t x√°o tr·ªôn'); return; }
        state.shufflesLeft--; $shuffles.textContent=state.shufflesLeft;
      }
      const items=[];
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const v=state.raw[r][c]; if(v && v!==OBSTACLE) items.push(v);
      }
      const mixed=shuffle(items); let k=0;
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const v=state.raw[r][c];
        if(v===OBSTACLE) continue;
        if(v!=='') state.raw[r][c]=mixed[k++];
      }
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) state.grid[r+1][c+1]=state.raw[r][c];
      draw();
    }

    // ====== AUTO SHUFFLE LOOP ======
    function startAutoShuffleLoop(){
      stopAutoShuffleLoop();
      state.autoShuffleTimerId=setInterval(()=>{
        if(state.paused || !state.autoShuffle) return;
        if(!findAnyPair()) shuffleBoard(true);
      }, 2000);
    }
    function stopAutoShuffleLoop(){ if(state.autoShuffleTimerId){ clearInterval(state.autoShuffleTimerId); state.autoShuffleTimerId=null; } }

    // ====== PAUSE/RESUME + PH√çM T·∫ÆT ======
    function setButtonsDisabled(dis){
      document.getElementById('btnHint').disabled=dis;
      document.getElementById('btnShuffle').disabled=dis;
      document.getElementById('btnRestart').disabled=dis;
    }
    function pauseGame(){ if(state.paused) return; state.paused=true; stopTimer(); setButtonsDisabled(true); $overlay.hidden=false; toast('ƒê√£ t·∫°m d·ª´ng'); }
    function resumeGame(){ if(!state.paused) return; state.paused=false; resetTimer(true); setButtonsDisabled(false); $overlay.hidden=true; toast('Ti·∫øp t·ª•c'); }

    document.getElementById('btnHint').addEventListener('click', hint);
    document.getElementById('btnShuffle').addEventListener('click', ()=> shuffleBoard(false));
    document.getElementById('btnPause').addEventListener('click', ()=> state.paused? resumeGame() : pauseGame());
    document.getElementById('btnRestart').addEventListener('click', ()=>{ state.score=0; updateScore(); startLevel(1); saveLastLevel(1); });
    $btnResume.addEventListener('click', resumeGame);
    $btnRestart2.addEventListener('click', ()=>{ $overlay.hidden=true; state.score=0; updateScore(); startLevel(1); saveLastLevel(1); });
/* ƒë·∫£m b·∫£o ph·∫ßn t·ª≠ c√≥ [hidden] th·∫≠t s·ª± ·∫©n */
.overlay[hidden]{ display: none !important; }

    document.addEventListener('keydown', e=>{
      if(e.repeat) return; const k=e.key.toLowerCase();
      if(k==='p'){ state.paused? resumeGame() : pauseGame(); }
      else if(k==='h' && !state.paused){ hint(); }
      else if(k==='r'){ state.score=0; updateScore(); startLevel(1); saveLastLevel(1); }
    });

    $optAutoShuffle.addEventListener('change', ()=>{ state.autoShuffle=$optAutoShuffle.checked; saveOptions(); if(state.autoShuffle) startAutoShuffleLoop(); else stopAutoShuffleLoop(); });
    $optFastTimer.addEventListener('change', ()=>{ state.fastTimer=$optFastTimer.checked; saveOptions(); if(!state.paused) resetTimer(true); });

    // ====== KH·ªûI ƒê·ªòNG ======
    (function renderLegend(){
      const legend=document.getElementById('legend'); legend.innerHTML='';
      for(let i=1;i<=8;i++){ const d=document.createElement('div'); d.className='tile';
        const img=document.createElement('img'); img.alt=`icon_${i}`; img.src=ASSET.iconUrl(i);
        img.onerror=()=>{ img.remove(); d.textContent=String(i); };
        d.appendChild(img); legend.appendChild(d);
      }
      const ob=document.createElement('div'); ob.className='tile obstacle';
      const oi=document.createElement('img'); oi.alt='Obstacle'; oi.src=ASSET.obstacleUrl;
      oi.onerror=()=>{ oi.remove(); ob.textContent='ü™®'; };
      ob.appendChild(oi); legend.appendChild(ob);
    })();

    loadPersist(); startLevel(state.level||1); startAutoShuffleLoop();
  </script>
</body>
</html>

